//#![no_std]

//#![feature(alloc)]

use core::iter::FromIterator;

extern crate alloc;
use alloc::boxed::Box;
use alloc::collections::btree_map::BTreeMap;
use alloc::string::String;
use alloc::string::ToString;
use alloc::vec::Vec;

extern crate proc_macro;
extern crate quote;
extern crate syn;

use std::fs;
use std::fs::OpenOptions;
use std::io::prelude::*;

use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use syn::{parse_macro_input, Token};

// If true it creates a file under debug/state_debug_code_STRUCTNAME.rs
// which contains the rust code that was generated by this lib.
static DO_PRINTING: bool = true;

// If true it creates a file under debug/transitions_STRUCTNAME_possible.gv
// which can be rendered with 'dot -Tsvg INPUT -o possible.svg'.
// This picture contains all possible states in the state machine
static DO_TRANSITION_PRINTING: bool = true;

// If true it creates a file under debug/transitions_STRUCTNAME_used.gv
// which can be rendered with 'dot -Tsvg INPUT -o used.svg'
// This picture contains all used states in the state machine
static DO_TRANSITION_PRINTING_OWN_TRANSITIONS: bool = true;

// If true all possible init transition gets printen to the graphs above
static DO_PRINTING_INITIAL_TRANSITIONS: bool = true;

// Some string thats used in the generated code.
// Gets append to avoid possible colissions in bigger projects.
// Negative aspect is that the code generated with this is a bit harder to read.
// You can change this (also to empty strings) if you want.
static TRAIT_NAME_FOR_INIT_CONSTRUCTOR: &str = "_InitialConstructor";
static TRAIT_NAME_FOR_STATE_CONVERTER: &str = "_StateConverter";
static MODE_NAME: &str = "_mode";

// If true the name of the states will be changed to STUCTNAME_state_STATENAME
// if false the name wont be changed.
// This is to aoid colissions in bigger projects.
// Disable to achieve more readble code in the debug folder
static RENAME_STATES: bool = true;

// Some string thats used in the generated code.
// You may can change this. But not to empty strings!
static CONTRUCTOR_NAME: &str = "contruct_with_state";
static STATE_MODE_NAME: &str = "typestate_mode";

#[proc_macro_attribute]

// This function reads and parse the given state machine and creates all needed states as structs.
// Also adds a type to the given struct. This type can only be from the set out of all given states.
// After that all possible transition gets generated.
// We used trait for that which we generate for each possible transition. Its just a "state converte"
// and build just a new object out of the given one. Just copying all values and change the state to the new one.
pub fn add_states(args: TokenStream, function: TokenStream) -> TokenStream {
    let mut parsed_function = parse_macro_input!(function as syn::ItemStruct);

    let struct_name = parsed_function.ident.to_string();
    let trait_name = struct_name.clone() + "States";
    let mut struct_string: String = "trait ".to_string() + &trait_name + "{}";
    let parsed_args = parse_add_states_arguments(args, struct_name.clone());

    let mut output_tokenstream: TokenStream = proc_macro::TokenStream::new();

    ////////////////////////////////////////////////////////////////
    // Creating state structs out of given arguments
    ////////////////////////////////////////////////////////////////
    append_string_to_token_stream(
        &mut output_tokenstream,
        "#[just_a_comment(\"Creating all given states.\")]".to_string(),
    );
    for state in parsed_args.0 {
        let derive_copy = "#[derive(Clone)]".to_string();
        struct_string += &derive_copy;
        struct_string += &("struct ".to_string() + &state + ";");
        struct_string += &("impl ".to_string() + &trait_name + " for " + &state + "{}");
    }
    let struct_tkn: TokenStream = struct_string.parse().unwrap();
    output_tokenstream.extend(struct_tkn);

    ////////////////////////////////////////////////////////////////
    // Adding generic and STATE_MODE_NAME as struct field
    ////////////////////////////////////////////////////////////////

    append_string_to_token_stream(&mut output_tokenstream, "#[just_a_comment(\"Here is your given struct as generic which accepts all given states.\")]".to_string());

    let dummy_struct: TokenStream = ("struct tmp <".to_string()
        + &struct_name.clone()
        + MODE_NAME
        + &": ".to_string()
        + &trait_name.clone()
        + "> {"
        + STATE_MODE_NAME
        + ": "
        + &struct_name.clone()
        + MODE_NAME
        + "}")
        .parse()
        .unwrap();

    let derive_copy = "#[derive(Clone)]".to_string();
    append_string_to_token_stream(&mut output_tokenstream, derive_copy);

    let dummy_struct_as_item = parse_macro_input!(dummy_struct as syn::ItemStruct);

    parsed_function.generics = dummy_struct_as_item.generics;

    let org_fields: syn::Fields;
    if let syn::Fields::Named(mut fields_named) = parsed_function.fields.clone() {
        if let syn::Fields::Named(new_fields_named) = dummy_struct_as_item.fields.clone() {
            fields_named.named.push(new_fields_named.named[0].clone());
        }
        org_fields = syn::Fields::Named(syn::FieldsNamed {
            brace_token: fields_named.brace_token,
            named: fields_named.named,
        });
        parsed_function.fields = org_fields;
    }

    let output = quote! { #parsed_function };
    let output_function: TokenStream = output.into();

    output_tokenstream.extend(output_function);

    ////////////////////////////////////////////////////////////////
    // Creating state machine builder
    ////////////////////////////////////////////////////////////////
    // Impl state machine builder for every possible transition

    append_string_to_token_stream(
        &mut output_tokenstream,
        "\n\n\n#[just_a_comment(\"Impl state machine builder for every possible transition\")]\n"
            .to_string(),
    );

    let trait_new_name: String = struct_name.clone() + TRAIT_NAME_FOR_STATE_CONVERTER;

    // Creating new trait
    let trt: String = "trait ".to_string()
        + &trait_new_name
        + " <T: "
        + &trait_name
        + "> { fn "
        + CONTRUCTOR_NAME
        + " (self) -> "
        + &struct_name
        + " <T>; }";

    append_string_to_token_stream(&mut output_tokenstream, trt);

    let mut struct_string: String = String::new();

    for (s_from, s_to) in parsed_args.1 {
        struct_string += &("impl ".to_string()
            + &trait_new_name
            + "<"
            + &s_to
            + "> for "
            + &struct_name
            + "<"
            + &s_from
            + "> { fn "
            + CONTRUCTOR_NAME
            + " (self) -> "
            + &struct_name
            + "<"
            + &s_to
            + "> { "
            + &struct_name
            + "{");

        if let syn::Fields::Named(fields_named) = parsed_function.fields.clone() {
            for fields in fields_named.named {
                let current_field = fields.ident.unwrap().to_string();
                if current_field == STATE_MODE_NAME.to_string() {
                    continue;
                }
                struct_string +=
                    &(" ".to_string() + &current_field + ": self." + &current_field + ",");
            }
            struct_string += &(STATE_MODE_NAME.to_string() + ": " + &s_to + "}}}");
        }
    }
    append_string_to_token_stream(&mut output_tokenstream, struct_string);

    if DO_PRINTING {
        write_to_file(struct_name, output_tokenstream.to_string(), false);
    }

    output_tokenstream
}

// This function gets the complete impl for block.
// It use the transition, require_state and constructor to decide what is to do and call the corresponding functions.
// At the end all states get looped and and for each state a impl for gets generated.
// In this impl all functions that are only valid in this state gets inserted.
#[proc_macro_attribute]
pub fn impl_for(_args: TokenStream, function: TokenStream) -> TokenStream {
    let mut output_tokenstream: TokenStream = proc_macro::TokenStream::new();
    let parsed_function = parse_macro_input!(function as syn::ItemImpl);

    let mut state_to_fn_map = BTreeMap::new();

    let struct_name: String;
    if let syn::Type::Path(tp) = Box::leak(parsed_function.self_ty.clone()) {
        struct_name = tp.path.segments[0].ident.to_string();
    } else {
        panic!(
            "Error: Unable to parse struct name in impl_for()\n{:?})\n\n‚Äù",
            parsed_function
        );
    }

    if DO_TRANSITION_PRINTING {
        write_transitions_to_file(
            struct_name.clone() + "_used",
            String::new(),
            String::new(),
            String::new(),
            false,
            true,
            false,
        );
    }

    // Looping all functions.
    for impl_item in parsed_function.items {
        let mut attribut_name: String = String::new();

        if let syn::ImplItem::Method(impl_item_method) = impl_item.clone() {
            'attribute_loop: for attribut in impl_item_method.clone().attrs {
                for segment in attribut.path.segments {
                    attribut_name = segment.ident.to_string();
                    if attribut_name != "transition"
                        && attribut_name != "require_state"
                        && attribut_name != "constructor"
                    {
                        continue 'attribute_loop;
                    }
                }

                for tokens in attribut.tokens {
                    let unparsed_args = tokens.to_string();

                    if attribut_name == "transition" {
                        impl_for_transition(
                            unparsed_args.clone(),
                            struct_name.clone(),
                            impl_item_method.clone(),
                            &mut state_to_fn_map,
                        );
                    } else if attribut_name == "require_state" {
                        let states = parse_impl_for_require_states_argument(unparsed_args);

                        for mut state in states {
                            if DO_TRANSITION_PRINTING && DO_TRANSITION_PRINTING_OWN_TRANSITIONS {
                                write_transitions_to_file(
                                    struct_name.clone() + "_used",
                                    state.clone(),
                                    state.clone(),
                                    impl_item_method.sig.ident.to_string(),
                                    false,
                                    false,
                                    false,
                                );
                            }

                            state = rename_state(state.clone(), struct_name.clone());
                            // Adding key, value to map (key = state, value = function).
                            state_to_fn_map.entry(state.clone()).or_insert(Vec::new());

                            if let Some(state_vec) = state_to_fn_map.get_mut(&state) {
                                state_vec.push(impl_item.clone());
                            }
                        }
                    } else if attribut_name == "constructor" {
                        let tkn = impl_for_constructor(
                            unparsed_args.clone(),
                            struct_name.clone(),
                            impl_item.clone(),
                            impl_item_method.clone(),
                        );
                        output_tokenstream.extend(tkn);
                    }
                }
            }
        }
    }

    // Looping all states and creating the impl for the current stat with all needed functions,
    for (state, fns) in state_to_fn_map {
        append_string_to_token_stream(
            &mut output_tokenstream,
            "#[just_a_comment(\"Impl all functions for state: ".to_string()
                + &state.clone()
                + "\")]",
        );
        let tmp_impl: TokenStream = ("impl ".to_string() + &struct_name + "<" + &state + "> {}")
            .parse()
            .unwrap();
        let mut tmp_parsed_impl = parse_macro_input!(tmp_impl as syn::ItemImpl);

        tmp_parsed_impl.items = fns.clone();
        let output = quote! { #tmp_parsed_impl };
        let output_function: TokenStream = output.into();
        output_tokenstream.extend(output_function);
    }

    if DO_PRINTING {
        write_to_file(struct_name.clone(), output_tokenstream.to_string(), true);
    }

    if DO_TRANSITION_PRINTING {
        write_transitions_to_file(
            struct_name.clone() + "_used",
            String::new(),
            String::new(),
            String::new(),
            false,
            false,
            true,
        );
    }

    output_tokenstream
}

// not doing anything, its for parsing only in the impl_for to indicate a required state
#[proc_macro_attribute]
pub fn require_state(_args: TokenStream, function: TokenStream) -> TokenStream {
    function
}

// not doing anything, its for parsing only in the impl_for to indicate  a transition
#[proc_macro_attribute]
pub fn transition(_args: TokenStream, function: TokenStream) -> TokenStream {
    function
}

// not doing anything, its for parsing only in the impl_for to indicate a constructor for an init state
#[proc_macro_attribute]
pub fn constructor(_args: TokenStream, function: TokenStream) -> TokenStream {
    function
}

// not doing anything, just to use it to save comments in syn::Attributes
// Otherwise we are unable to add comments to the generated code
#[proc_macro_attribute]
pub fn just_a_comment(_args: TokenStream, function: TokenStream) -> TokenStream {
    function
}

////////////////////////////////////////////////////////////////////////////////////////////////
// argument helper
////////////////////////////////////////////////////////////////////////////////////////////////

/// Parsing arguments for the add_states macro, returning a tuple with (all states, all transitions) both as vectors
/// A valid example:
/// #[add_states( "States: Off, On | Transitions: Off -> On, On -> Off)]
///
fn parse_add_states_arguments(
    args: TokenStream,
    struct_name: String,
) -> (Vec<String>, Vec<(String, String)>) {
    let mut args_as_string: String = args.clone().to_string();

    args_as_string.retain(|c| !c.is_whitespace() && c != '"');

    if !args_as_string.contains("States:") {
        panic!(
            "Unable to find the required keyword 'States'. {:?}",
            args_as_string
        );
    }
    if !args_as_string.contains("Transitions:") {
        panic!(
            "Unable to find the required keyword 'Transitions'. {:?}",
            args_as_string
        );
    }

    args_as_string = args_as_string.split("States:").collect();
    args_as_string = args_as_string.split("Transitions:").collect();

    let states_and_transitions: Vec<String> =
        Vec::from_iter(args_as_string.split(";").map(String::from));

    if states_and_transitions.len() != 2 {
        panic!("Unable to split 'States' and 'Transitions'. You may forgot to seperate it with a ';'. {:?}", args_as_string);
    }

    let unparsed_states: String = states_and_transitions[0].clone();
    let unparsed_transitions: String = states_and_transitions[1].clone();

    let tmp_states: Vec<String> = Vec::from_iter(unparsed_states.split(",").map(String::from));

    // change all states to name
    let mut states: Vec<String> = Vec::new();
    for state in tmp_states {
        states.push(rename_state(state, struct_name.clone()));
    }

    let transitions: Vec<String> =
        Vec::from_iter(unparsed_transitions.split(",").map(String::from));

    let mut possible_transitions: Vec<(String, String)> = Vec::new();

    write_transitions_to_file(
        struct_name.clone() + "_possible",
        String::new(),
        String::new(),
        String::new(),
        false,
        true,
        false,
    );

    for trans in transitions {
        let tmp: Vec<&str> = trans.split("->").collect();
        let from_states_unparsed: String = tmp[0].to_string();
        let from_states: Vec<&str> = from_states_unparsed.split("|").collect();
        for from_state_tmp in from_states {
            let mut from_state: String = from_state_tmp.to_string();
            let mut to_state: String = tmp[1].to_string();
            from_state.retain(|c| !c.is_whitespace());
            to_state.retain(|c| !c.is_whitespace());

            write_transitions_to_file(
                struct_name.clone() + "_possible",
                from_state.clone(),
                to_state.clone(),
                String::new(),
                false,
                false,
                false,
            );

            from_state = rename_state(from_state, struct_name.clone());
            to_state = rename_state(to_state, struct_name.clone());

            if from_state == to_state {
                panic!(
                    "Invalid transition in add_states: Source and target are the same state. {:?}.",
                    from_state
                );
            }

            possible_transitions.push((from_state, to_state));
        }
    }

    write_transitions_to_file(
        struct_name.clone() + "_possible",
        String::new(),
        String::new(),
        String::new(),
        false,
        false,
        true,
    );

    (states, possible_transitions)
}

// Parsing the transition argumetns
// Valid input: '(sourceState -> destinationState)' or '(stateA | stateB -> dstState)'
// Returning a tulpe. First element is a vector with all possible source states
// second element is the destination state
fn parse_impl_for_transition_arguments(
    state_name: String,
    struct_name: String,
    fun_method: syn::ImplItemMethod,
) -> (Vec<String>, String) {
    let tmp: Vec<&str> = state_name.split("->").collect();

    if tmp.len() != 2 {
        panic!(
            "Unable to parse the transition states of {:?}, {:?}. No '->' found {:?}",
            struct_name,
            fun_method.sig.ident.to_string(),
            state_name
        );
    }

    let mut to_state: String = tmp[1].to_string();
    to_state.retain(|c| !c.is_whitespace() && c != '(' && c != ')');

    let aaa = tmp[0].to_string();
    let from_states: Vec<&str> = aaa.split("|").collect();

    let mut re: Vec<String> = Vec::new();
    for state in from_states {
        let mut tmp = state.to_string();
        tmp.retain(|c| !c.is_whitespace() && c != '(' && c != ')');
        re.push(tmp);
    }

    (re, to_state)
}

// parse the string '(stateA | stateB)' to a vector, seperated by '|'
fn parse_impl_for_require_states_argument(args: String) -> Vec<String> {
    let mut tmp = args.clone();
    tmp.retain(|c| !c.is_whitespace() && c != '(' && c != ')');

    let states: Vec<String> = Vec::from_iter(tmp.split("|").map(String::from));

    states
}

////////////////////////////////////////////////////////////////////////////////////////////////
//  helper
////////////////////////////////////////////////////////////////////////////////////////////////

fn create_syn_ident(name: String) -> syn::Ident {
    syn::Ident::new(&name, Span::call_site())
}

fn rename_state(state_name: String, struct_name: String) -> String {
    if RENAME_STATES {
        struct_name + "_state_" + &state_name
    } else {
        struct_name
    }
}

fn append_string_to_token_stream(tk: &mut proc_macro::TokenStream, st: String) {
    let trt: TokenStream = st.parse().unwrap();

    tk.extend(trt);
}

// This function first creates the InitialConstructor trait which contains the constructor.
// For this we need to build a dummy trait, and add all parameters from the original constructor to the dummy
// Then we loop all initial states and build a impl for each state. Each impl contains the constructor.
fn impl_for_constructor(
    unparsed_args: String,
    struct_name: String,
    fun: syn::ImplItem,
    fun_method: syn::ImplItemMethod,
) -> TokenStream {
    let impl_item = fun.clone();

    let states = parse_impl_for_require_states_argument(unparsed_args);

    if states.len() == 0 {
        panic!(
            "Unable to parse the states of '{:?}'.",
            fun_method.sig.ident.to_string()
        );
    }

    let mut output_tokenstream: TokenStream = proc_macro::TokenStream::new();

    ////////////////////////////////////////////////////////////////
    // Adding trait TRAIT_NAME_FOR_INIT_CONSTRUCTOR
    ////////////////////////////////////////////////////////////////
    let trait_name = struct_name.clone() + "States";
    append_string_to_token_stream(
        &mut output_tokenstream,
        "#[just_a_comment(\"Creating trait for needed new() function.\")]".to_string(),
    );

    // building dummy trait
    let trt: TokenStream = ("trait ".to_string()
        + &struct_name.clone()
        + TRAIT_NAME_FOR_INIT_CONSTRUCTOR
        + " <T: "
        + &trait_name
        + "> {
    fn new() -> "
        + &struct_name.clone()
        + "<T>;}")
        .parse()
        .unwrap();

    // parse dummy trait to ItemTrait
    let mut dummy_trait = parse_macro_input!(trt as syn::ItemTrait);

    // Insert all parameters (syn::TraitItem::Method::sig::inputs) from given function into du·∏ømy
    if let syn::TraitItem::Method(mut x) = dummy_trait.items[0].clone() {
        if let syn::ImplItem::Method(y) = impl_item.clone() {
            x.sig.inputs = y.sig.inputs;
        }
        dummy_trait.items[0] = syn::TraitItem::Method(x);
    }

    // build dummy and add it it to the output stream
    let output = quote! { #dummy_trait };
    let output_function: TokenStream = output.into();

    append_string_to_token_stream(&mut output_tokenstream, output_function.to_string());

    for mut state in states {
        append_string_to_token_stream(
            &mut output_tokenstream,
            "#[just_a_comment(\"Impl new() for state: ".to_string() + &state.clone() + " \")]",
        );

        // reset function for each state
        let mut impl_item = fun.clone();

        if DO_TRANSITION_PRINTING && DO_PRINTING_INITIAL_TRANSITIONS {
            write_transitions_to_file(
                struct_name.clone() + "_used",
                "init_".to_string() + &state.clone(),
                state.clone(),
                fun_method.sig.ident.to_string(),
                true,
                false,
                false,
            );
        }

        state = rename_state(state, struct_name.clone());

        let dummy_function: TokenStream = ("fn tmp () ->".to_string()
            + &struct_name
            + "<"
            + &state
            + "> { "
            + &struct_name.clone()
            + "{}}")
            .parse()
            .unwrap();

        let dummy_function_as_item = parse_macro_input!(dummy_function as syn::ItemFn);

        if let syn::ImplItem::Method(mut x) = impl_item.clone() {
            // adding return type
            x.sig.output = dummy_function_as_item.sig.output.clone();

            // adding to the last statement in the "new" function the "mode" field to the struct contruction
            // this is quit a bit not easy to understand code - but thats how the syntax tree works...
            // A bit confusing, but you have to check the syn doc to understand the structure.
            let sstt = x.block.stmts.last_mut().unwrap();
            if let syn::Stmt::Expr(expr) = sstt.clone() {
                if let syn::Expr::Struct(mut expr_struct) = expr.clone() {
                    let ident = create_syn_ident(STATE_MODE_NAME.to_string());
                    let member = syn::Member::Named(ident);

                    let idnt = create_syn_ident(state.clone());

                    let path_segment = syn::PathSegment {
                        ident: idnt,
                        arguments: syn::PathArguments::None,
                    };
                    let mut punctuated: syn::punctuated::Punctuated<
                        syn::PathSegment,
                        syn::token::Colon2,
                    > = syn::punctuated::Punctuated::new();
                    punctuated.push(path_segment);
                    let qself = None;
                    let path = syn::Path {
                        leading_colon: None,
                        segments: punctuated,
                    };

                    let expr_path = syn::ExprPath {
                        attrs: Vec::new(),
                        qself: qself,
                        path: path,
                    };

                    let expr = syn::Expr::Path(expr_path);

                    let new_colon_token: Option<syn::token::Colon> =
                        Some(Token![:](Span::call_site()));
                    let field = syn::FieldValue {
                        attrs: Vec::new(),
                        member: member,
                        colon_token: new_colon_token,
                        expr: expr,
                    };

                    let mut new_punc: syn::punctuated::Punctuated<
                        syn::FieldValue,
                        syn::token::Comma,
                    > = syn::punctuated::Punctuated::new();

                    new_punc.push(field.clone());

                    expr_struct.fields.push(field.clone());

                    let tmp = syn::Expr::Struct(expr_struct);
                    let tmp1 = syn::Stmt::Expr(tmp);
                    *sstt = tmp1;
                }
            }

            impl_item = syn::ImplItem::Method(x);
        }

        // building and parsing impl dummy
        let new_trait: TokenStream = ("impl ".to_string()
            + &struct_name.clone()
            + TRAIT_NAME_FOR_INIT_CONSTRUCTOR
            + "<"
            + &state.clone()
            + "> for "
            + &struct_name.clone()
            + "<"
            + &state.clone()
            + "> {} ")
            .parse()
            .unwrap();

        let mut parsed_new_trait = parse_macro_input!(new_trait as syn::ItemImpl);
        let mut vec: Vec<syn::ImplItem> = Vec::new();
        vec.push(impl_item.clone());
        parsed_new_trait.items = vec;

        let output = quote! { #parsed_new_trait };
        let output_function: TokenStream = output.into();
        output_tokenstream.extend(output_function);
    }

    output_tokenstream
}

// Creating code for transitions in impl.
// Needs to return a TokenStream because parse_macro_input forces it. Dont know why... but its ok.
fn impl_for_transition(
    unparsed_args: String,
    struct_name: String,
    fun_method: syn::ImplItemMethod,
    map: &mut BTreeMap<String, Vec<syn::ImplItem>>,
) -> TokenStream {
    if unparsed_args == "()" {
        panic!(
            "Transition arguments are empty for {:?}, {:?}.",
            struct_name,
            fun_method.sig.ident.to_string()
        );
    }

    let transition = parse_impl_for_transition_arguments(
        unparsed_args.clone(),
        struct_name.clone(),
        fun_method.clone(),
    );

    // Checking if everything is okay, else panic. Otherwise you will have no idea where the problem is

    if transition.0.len() == 0 {
        panic!(
            "Unable to parse the transition states of {:?}, {:?}. No required state given",
            struct_name,
            fun_method.sig.ident.to_string()
        );
    }

    for trans in transition.0.clone() {
        if trans.is_empty() {
            panic!(
                "Unable to parse the transition states of {:?}, {:?}. Maybe there is an unused '|'? {:?}",
                struct_name,
                fun_method.sig.ident.to_string(),
                unparsed_args
            );
        }
    }

    if transition.1.is_empty() {
        panic!(
            "Unable to parse the transition states of {:?}, {:?}. No target state given",
            struct_name,
            fun_method.sig.ident.to_string()
        );
    }
    // Checking done

    let to_state = &rename_state(transition.1.clone(), struct_name.clone());

    for state in transition.0.clone() {
        let from_state = rename_state(state.to_string().clone(), struct_name.clone());
        if DO_TRANSITION_PRINTING {
            write_transitions_to_file(
                struct_name.clone() + "_used",
                state.to_string(),
                transition.1.clone(),
                fun_method.sig.ident.to_string(),
                false,
                false,
                false,
            );
        }

        ////////////////////////////////////////////////////////////////////////////////////////////////
        // Modify given function
        ////////////////////////////////////////////////////////////////////////////////////////////////
        let dummy_function: TokenStream = ("fn tmp () ->".to_string()
            + &struct_name.clone()
            + "<"
            + &to_state.clone()
            + "> { "
            + &struct_name.clone()
            + "::"
            + CONTRUCTOR_NAME
            + "(self)}")
            .parse()
            .unwrap();

        let dummy_function_as_item = parse_macro_input!(dummy_function as syn::ImplItemMethod);

        let impl_item: syn::ImplItem;

        let mut impl_item_method = fun_method.clone();

        // Adding return statement as last element of block
        impl_item_method
            .block
            .stmts
            .push(dummy_function_as_item.block.stmts[0].clone());

        // Adding return type
        impl_item_method.sig.output = dummy_function_as_item.sig.output.clone();
        impl_item = syn::ImplItem::Method(impl_item_method);

        // Adding key, value to map (key = state, value = function)
        map.entry(from_state.clone()).or_insert(Vec::new());
        if let Some(state_vec) = map.get_mut(&from_state) {
            state_vec.push(impl_item);
        } else {
            panic!("Unable to push fn to state map");
        }
    }
    TokenStream::new()
}

////////////////////////////////////////////////////////////////////////////////////////////////
// Outputer for generated code and graphs
////////////////////////////////////////////////////////////////////////////////////////////////
#[allow(unused)]
fn write_to_file(struct_name: String, mut content: String, do_append: bool) {
    fs::create_dir_all("./debug").unwrap();

    let mut file = OpenOptions::new()
        .write(true)
        .create(!do_append)
        .append(do_append)
        .truncate(!do_append)
        .open("./debug/".to_string() + &struct_name + "_generated_states.rs")
        .unwrap();
    file.write_all(content.as_bytes())
        .expect("Unable to write to file.");
}

// Plot with "dot -Tsvg transitions_CoffeeMachine.gv  -o graph.svg"
#[allow(unused)]
fn write_transitions_to_file(
    struct_name: String,
    from_state: String,
    to_state: String,
    function_name: String,
    is_init_transition: bool,
    init: bool,
    finalize: bool,
) {
    let mut content: String;

    fs::create_dir_all("./debug").unwrap();

    let mut file = OpenOptions::new()
        .write(true)
        .create(init)
        .truncate(init)
        .append(!init || finalize)
        .open("./debug/".to_string() + &struct_name + "_transitions.gv")
        .unwrap();

    if init {
        content = "digraph ".to_string()
            + &struct_name
            + &"{\n    rankdir=LR;\n    size=\"10,5\"\n    node [shape = circle];\n\n\n"
                .to_string();
    } else if finalize {
        content = "}".to_string();
    } else {
        content = "    ".to_string()
            + &from_state
            + " -> "
            + &to_state
            + " [ label = \""
            + &function_name
            + "\" ];\n";
        if is_init_transition {
            content += &("    ".to_string() + &from_state + " [shape = none, label = \"\"];\n");
        }
    }
    file.write_all(content.as_bytes())
        .expect("Unable to write to  file.");
}
